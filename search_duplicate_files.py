'''
Скрипт рекурсивного поиска (по хэшам) и удаления дубликатов файлов в указанном каталоге
@author Пацуков А.А.

Нужно например, когда у вас тысячи фотографий и могут быть дубликаты в
разных каталогах и их нужно удалить, чтобы зря не занимать место на диске.
Т.е. если есть много папок/подпапок в главном каталоге, где лежит скрипт, с
дубликатами фотографий которые одинаковые(не редактированные) относительно
друг-друга, и лишь имеют разные имена файлов - хэш таких файлов всегда будет
одинаковый, так и можно найти дубликаты фотографий.

Так же ищет и удаляет дубликаты: видеофайлов, эл.книг и т.п.
'''
import os
import hashlib

hashmap = {}
count = 0
size = 0


def convert_bytes(num):
    """Конвертирование байтов в KB, MB, GB, TB"""
    for x in ['bytes', 'KB', 'MB', 'GB', 'TB']:
        if num < 1024.0:
            return "%3.1f %s" % (num, x)
        num /= 1024.0


for patch, dirs, files in os.walk('.'):
    for filename in files:
        # Получаем полное имя-путь к файлу
        fullname = os.path.join(patch, filename)
        # Пропустим сам файл нашего запущенного скрипта:
        if fullname == __file__:
            continue
        # Читаем файлы в двоичном режиме, чтобы избежать кодирования символов
        # и проблем с преобразованием конца строки
        with open(fullname, 'rb', buffering=0) as f:
            # выбор алгоритма хэширования
            h = hashlib.sha256()
            # Не читаем полный файл в памяти, чтобы не тратить память.
            # Последовательно читаем блок за блоком и обновляем хэш для
            # каждого блока, что позволяет использовать оптимальный размер
            # блока
            for b in iter(lambda: f.read(128 * 1024), b''):
                h.update(b)
            # Получаем хэш-файла в виде hex-представления
            hash = h.hexdigest()

            # Если найденный хэш-файла не встречался ранее, то добавляем его и
            # имя его файла в кортеж
            if hash not in hashmap.keys():
                hashmap.setdefault(hash, fullname)
            else:
                # Если же встречался, значит нам попался дубликат, и значит
                # нужно удалить его с диска (не в корзину, а безвозвратно!)
                # Сохраним размер файла в байтах
                size += os.stat(fullname).st_size
                # удаляем файл
                os.remove(fullname)
                count += 1
                print('Удалили дубликат: ', fullname)

print(f"\nВсего удалено: {count} файлов, суммарным размером: ",
      convert_bytes(size))
